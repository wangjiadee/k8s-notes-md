# 14、安全配置管理

 授权插件: Node , ABAC,RBAC,Webhook（基于http的回调机制）

 

## 14.1 k8s的安全框架

访问K8S集群的资源需要过三关：认证、鉴权、准入控制

普通用户若要安全访问集群API Server，往往需要证书、Token或者用户名+密码；Pod访问，比如ingress控制器Ui的Dashboard都需要ServiceAccount，主要是让这个容器能够访问这个API，也就是所有的交互都是通过API的，这可能通过一个人去通过kubectl去交互，也有可能你的程序去调用API，但这些都是需要授权的。

• K8S安全控制框架主要由下面3个阶段进行控制，每一个阶段都支持插件方式，通过API Server配置来启用插件。

1. Authentication 认证

   ​     API收到用户发送的请求之后，他会先认证,认证它这边有三个可以做到

   ​	三种客户端身份认证：

   • HTTPS 证书认证：基于CA证书签名的数字证书认证，也就是k8s,CA签出来的证书可以作为你客户端访问携带的证书，它会帮你认证，这是一种方式，从这个证书里面去提取你有没有权限去访问。
   • HTTP Token认证：通过一个Token来识别用户。
   • HTTP Base认证：用户名+密码的方式认证，这是基于http自身的一个认证，不过这个很少人去用，因为安全系数比较低。

2. Authorization 鉴权

   RBAC（Role-Based Access Control，基于角色的访问控制）：负责完成授权（Authorization）工作。也就是会查看你的访问符不符合权限，所以它会在这个地方去给你判断，如果你来的这个身份，虽然有这个身份，但是没有这个权限访问这个资源，也会不允许你通过。

3. Admission Control 准入控制

简单讲就是开发将一些高级的功能，直接插件化的去设计，也就是准入控制器就是一个插件的集合，集合里面就有一些高级的特性，都是以插件去实现的，如果不启用这些插件的话，那你就使用不了这个功能，这也就是第三关，也就是你的请求会经过你的插件准入控制，准入控制呢会给你效验请求的实现的这个方法，到底这个插件有没有启用这一块，不过大多数的方式默认的插件都是启用的，启动之后来请求相关的资源，才会被允许，因为它启用插件了，如果没启动的话也会不通过

Adminssion Control实际上是一个准入控制器插件列表，发送到API Server的请求都需要经过这个列表中的每个准入控制器，插件的检查，检查不通过，则拒绝请求。

## 14.2	RBAC-基于角色访问权限配置

基于角色的权限访问控制（Role-Based Access Control） 作为传统访问控制（自主访问、强制访问）的有前景的代替 受到了广泛的关注。在RBAC中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。极大地简化了权限的管理。

![img](file:///C:\Users\WANGJI~1\AppData\Local\Temp\ksohtml14624\wps1.jpg)

RBAC支持三个著名的安全原则：最小权限原则、责任分离原则、数据抽象原则。

（1）因为RBAC可以将用户的角色配置成用户完成任务所需的最小的权限集。

（2）可以通过调用相互独立互斥的角色来共同完成敏感的任务。

（3）通过权限的抽象来体现数据抽象原则。eg：财务操作借款、存款等抽象权限，而不实际操作 系统提供的读、写、执行权限。



1.6 版本以上的都默认开启了 RBAC ，可以通过查看 Master 节点上

apiserver 的静态 Pod 定义⽂件：（我是用kubeadm 来搭建的  使用的是vs code 的管理工具查看）

```yaml
......omit.....
spec:
  containers:
  - command:
    - kube-apiserver
    - --advertise-address=192.168.208.41
    - --allow-privileged=true
    - --authorization-mode=Node,RBAC
    - --client-ca-file=/etc/kubernetes/pki/ca.crt
......omit.....
```

RBAC API 对象 

Kubernetes 有⼀个很基本的特性就是它的所有资源对象都是模型化的 API 对象，允许执⾏ CRUD(Create、Read、Update、Delete)操作(也就是我们常说的增、删、改、查操作)，⽐如下⾯的这 下资源：

​      Pods            ConfigMaps             Deployments             Nodes             Secrets                 Namespaces

上⾯这些资源对象的可能存在的操作有  create   get    delete   list   update    edit    watch    exec

在更上层，这些资源和 API Group 进⾏关联，⽐如 Pods 属于 Core API Group，⽽ Deployements 属 于 apps API Group，要在 Kubernetes 中进⾏ RBAC 的管理，除了上⾯的这些资源和操作以外，我们 还需要另外的⼀些对象：

- Rule：规则，规则是⼀组属于不同 API Group 资源上的⼀组操作的集合
- Role 和 ClusterRole：⻆⾊和集群⻆⾊，这两个对象都包含上⾯的 Rules 元素，⼆者的区别在 于，在 Role 中，定义的规则只适⽤于单个命名空间，也就是和 namespace 关联的，⽽ ClusterRole 是集群范围内的，因此定义的规则不受命名空间的约束。另外 Role 和 ClusterRole 在 Kubernetes 中都被定义为集群内部的 API 资源，和我们前⾯学习过的 Pod、ConfigMap 这些 类似，都是我们集群的资源对象，所以同样的可以使⽤我们前⾯的 kubectl 相关的命令来进⾏操 作

![img](file:///C:\Users\WANGJI~1\AppData\Local\Temp\ksohtml14624\wps4.jpg)



- Subject：主题，对应在集群中尝试操作的对象，集群中定义了3种类型的主题资源：

![img](file:///C:\Users\WANGJI~1\AppData\Local\Temp\ksohtml14624\wps2.jpg)

1. User Account：⽤户，这是有外部独⽴服务进⾏管理的，管理员进⾏私钥的分配，⽤户可以 使⽤ KeyStone或者 Goolge 帐号，甚⾄⼀个⽤户名和密码的⽂件列表也可以。对于⽤户的管 理集群内部没有⼀个关联的资源对象，所以⽤户不能通过集群内部的 API 来进⾏管理 
2. Group：组，这是⽤来关联多个账户的，集群中有⼀些默认创建的组，⽐如cluster-admin
3.  Service Account：服务帐号，通过 Kubernetes API 来管理的⼀些⽤户帐号，和 namespace 进⾏关联的，适⽤于集群内部运⾏的应⽤程序，需要通过 API 来完成权限认证，所以在集群 内部进⾏权限操作，我们都需要使⽤到 ServiceAccount，这也是我们这节课的重点

- RoleBinding 和 ClusterRoleBinding：⻆⾊绑定和集群⻆⾊绑定，简单来说就是把声明的 Subject 和我们的 Role 进⾏绑定的过程(给某个⽤户绑定上操作的权限)，⼆者的区别也是作⽤范围的区 别：RoleBinding 只会影响到当前 namespace 下⾯的资源操作权限，⽽ ClusterRoleBinding 会影 响到所有的 namespace。

### 14.2.1创建⼀个只能访问某个 namespace 的⽤户

我们来创建⼀个 User Account，只能访问gomo-test这个命名空间：

username: ralph       group:gomo

第1步：创建⽤户凭证

Kubernetes 没有 User Account 的 API 对象，不过要创建⼀个⽤户帐号的话也是挺简单的，利⽤管理员分配给你的⼀个私钥就可以创建了，这个我们可以参考[官⽅⽂档](https://kubernetes.io/docs/reference/access-authn-authz/authentication/)中的⽅法，这⾥我们来使⽤ OpenSSL 证书来创建⼀个 User，当然我们也可以使⽤更简单的 cfssl ⼯具来创建：

给⽤户 ralph 创建⼀个私钥，命名成： ralph .key：

```
[root@adm-master2 home]# openssl genrsa -out ralph.key 2048
```

使⽤我们刚刚创建的私钥创建⼀个证书签名请求⽂件：ralph.csr，要注意需要确保在 -subj 参数中指定⽤户名和组(CN表示⽤户名，O表示组)

```
[root@adm-master2 home]# openssl req -new -key ralph.key -out ralph.csr -subj "/CN=ralph/O=gomo"
```

然后找到我们的 Kubernetes 集群的 CA ，我们使⽤的是 kubeadm 安装的集群， CA 相关证书位于 /etc/kubernetes/pki/ ⽬录下⾯，如果你是⼆进制⽅式搭建的，你应该在最开始搭建集群的时候就已经指定好了 CA 的⽬录，我们会利⽤该⽬录下⾯的 ca.crt 和 ca.key 两个⽂件来批准上⾯的证书请求(⽣成最终的证书⽂件，我们这⾥设置证书的有效期为900天)

```
[root@adm-master2 home]# openssl x509 -req -in ralph.csr -CA /etc/kubernetes/pki/ca.crt -CAkey /etc/kubernetes/pki/ca.key -CAcreateserial -out ralph.crt -days 900
Signature ok
subject=/CN=ralph/O=gomo
Getting CA Private Key

#现在查看我们当前⽂件夹下⾯是否⽣成了⼀个证书⽂件：
[root@adm-master2 home]# ls
ralph.crt  ralph.csr  ralph.key
```

现在我们可以使⽤刚刚创建的证书⽂件和私钥⽂件在集群中创建新的凭证和上下⽂(Context):

```
[root@adm-master2 home]# kubectl config set-credentials ralph --client-certificate=ralph.crt --client-key=ralph.key
User "ralph" set.
#我们可以看到⼀个⽤户 ralph 创建了，然后为这个⽤户设置新的 Context
[root@adm-master2 home]# kubectl config set-context ralph-context --cluster=kubernetes --namespace=gomo --user=ralph
Context "ralph-context" created.
```

到这⾥，我们的⽤户 haimaxy 就已经创建成功了，现在我们使⽤当前的这个配置⽂件来操 作 kubectl 命令的时候，应该会出现错误，因为我们还没有为该⽤户定义任何操作的权限

```
[root@adm-master2 home]# kubectl get pods --context=ralph-context
Error from server (Forbidden): pods is forbidden: User "ralph" cannot list resource "pods" in API group "" in the namespace "gomo"
```

第2步：创建⻆⾊ ⽤户创建完成后，接下来就需要给该⽤户添加操作权限，我们来定义⼀个 YAML ⽂件，创建⼀个允许 ⽤户操作 Deployment、Pod、ReplicaSets 的⻆⾊，如下定义：(ralph-role.yaml)

```
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: ralph-role
  namespace: gomo-test
rules:
- apiGroups: ["", "apps", "apps"]
  resources: ["deployments", "replicasets", "pods"]
  verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
```

其中 Pod 属于 core 这个 API Group，在 YAML 中⽤空字符就可以，⽽ Deployment 属于 apps 这个 API Group， ReplicaSets 属于 apps 这个 API Group可以查看对应版本的文档来查询[对应自己集群的版本](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.17/)，所以 rules 下⾯的 apiGroups 就综合了这⼏个资源的 API Group：["", "extensions", "apps"]，其中 verbs 就 是我们上⾯提到的可以对这些资源对象执⾏的操作，我们这⾥需要所有的操作⽅法，所以我们也可以 使⽤['*']来代替。

```
[root@adm-master1 home]# kubectl create -f ralph-role.yaml 
role.rbac.authorization.k8s.io/ralph-role created
```

第3步：创建⻆⾊权限绑Role 创建完成了，但是很明显现在我们这个 Role 和我们的⽤户ralph还没有任何关系，对吧？这 ⾥我就需要创建⼀个 RoleBinding 对象，在 gomo-test 这个命名空间下⾯将上⾯的 ralph-role ⻆⾊和⽤户 ralph 进⾏绑定:( ralph-rolebinding.yaml)

```
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: ralph-rolebinding
  namespace: gomo-test
subjects:
- kind: User
  name: ralph
  apiGroup: ""
roleRef:
  kind: Role
  name: ralph-role
  apiGroup: ""
```

上⾯的 YAML ⽂件中我们看到了 subjects 关键字，这⾥就是我们上⾯提到的⽤来尝试操作集群的对

象，这⾥对应上⾯的 User 帐号ralph，使⽤ kubectl 创建上⾯的资源对象.现在我们应该可以上⾯的 haimaxy-context 上下⽂来操作集群了：

```
[root@adm-master2 home]# kubectl --context=ralph-context get pods --namespace=gomo-test
No resources found in gomo-test namespace.
```

**PS**：证书在那个机器上做的  此命令就在那个机器上执行，如在master2上面创建的证书 在master1上面 就会报错：

```
[root@adm-master1 home]# kubectl --context=ralph-context get pods --namespace=gomo-test
error: context "ralph-context" does not exist
```

同时 创建的只对你但是所设定的命名空间有效，其他命名空间就会报错

```
[root@adm-master2 home]# kubectl --context=ralph-context get pods --namespace=default
Error from server (Forbidden): pods is forbidden: User "ralph" cannot list resource "pods" in API group "" in the namespace "default"
```

### 14.2.2创建⼀个只能访问某个 namespace 的ServiceAccount

```
[root@adm-master2 home]# kubectl create sa ralph-sa -n gomo-test
serviceaccount/ralph-sa created
```

然后新建⼀个 Role 对象：(haimaxy-sa-role.yaml)

```
kubectl create -f haimaxy-sa-role.yaml
```

然后创建⼀个 RoleBinding 对象，将上⾯的 haimaxy-sa 和⻆⾊ haimaxy-sa-role 进⾏绑定：(haimaxysa-rolebinding.yaml)

```
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: ralph-sa-rolebinding
  namespace: gomo-test
subjects:
- kind: ServiceAccount
  name: ralph-sa
  namespace: gomo-test
roleRef:
  kind: Role
  name: ralph-sa-role
  apiGroup: rbac.authorization.k8s.io
```

```
kubectl create -f haimaxy-sa-rolebinding.yaml
```

然后我们怎么去验证这个 ServiceAccount 呢？我们前⾯的课程中是不是提到过⼀个 ServiceAccount 会⽣成⼀个 Secret 对象和它进⾏映射，这个 Secret ⾥⾯包含⼀个 token，我们可以利⽤这个 token 去 登录 Dashboard，然后我们就可以在 Dashboard 中来验证我们的功能是否符合预期了：

```
[root@adm-master2 home]# kubectl get secret -n gomo-test |grep ralph-sa
istio.ralph-sa         istio.io/key-and-cert                 3      6m25s
ralph-sa-token-h6sdj   kubernetes.io/service-account-token   3      6m26s
```

```
#通过ralph的tokens 去dashboard来认证：
[root@adm-master1 home]# kubectl describe secret ralph-sa-token-h6sdj -n gomo-test
token:      eyJhbGciOiJSUzI1NiIsImtpZCI6IkhnbVJnUGRpcHBqZG5OMVliUDV2ZlRTd0VxOFJWSnNaTzdhUnUtWExjUmcifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJnb21vLXRlc3QiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlY3JldC5uYW1lIjoicmFscGgtc2EtdG9rZW4taDZzZGoiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoicmFscGgtc2EiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC51aWQiOiIzYTcyYjA2Mi0yMDRiLTQ0NGQtYTlkMS1mYjljOTc4MDAyMzAiLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6Z29tby10ZXN0OnJhbHBoLXNhIn0.BpHXAFGmEXCLrKm7IODdEBs_La8NOUOhxfMcMFFun7XyxW_Oo8J4qBKjLR4vSdkGEnV1YrchhCZBLSUmkn0nlIkWLne8Ut5KlcyryvG9KG6ijt1wgRh_4bBfvVuUqK9WgcPa7LZXYthZ8SyHX2450CBpN8gwXdgfI6IKBL6gEl0Qc6uOwADWGCS8aXDiNJYKyqgrgpPs065WL8O4Y-7Cs93Z5DZOya_ZxMr98q77AV4D_6RlfYWoMS3lX_UBR1oc6irm8tZPOWA9SdWyL46i3ADjcZdjiz-PIVYkdNHbqeTak2YbWKKjPZQuvDnANQKC6jYcNaBEisYoEFlnPznS2A
```

![image-20200103110425382](C:\Users\wangjiadesx\AppData\Roaming\Typora\typora-user-images\image-20200103110425382.png)



### 14.2.3创建⼀个可以访问所有 namespace 的ServiceAccount

刚刚我们创建的 ralph-sa 这个 ServiceAccount 和⼀个 Role ⻆⾊进⾏绑定的，如果我们现在创建⼀ 个新的 ServiceAccount，需要他操作的权限作⽤于所有的 namespace，这个时候我们就需要使⽤到 ClusterRole 和 ClusterRoleBinding 这两种资源对象了。同样，⾸先新建⼀个 ServiceAcount 对象：



```
apiVersion: v1
kind: ServiceAccount
metadata:
  name: ralph-sa2
  namespace: gomo-test
---
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: ralph-sa2-clusterrolebinding
subjects:
- kind: ServiceAccount
  name: ralph-sa2
  namespace: gomo-test
roleRef:
  kind: ClusterRole
  name: cluster-admin
  apiGroup: rbac.authorization.k8s.io
```

从上⾯我们可以看到我们没有为这个资源对象声明 namespace，因为这是⼀个 ClusterRoleBinding 资 源对象，是作⽤于整个集群的，我们也没有单独新建⼀个 ClusterRole 对象，⽽是使⽤的 clusteradmin 这个对象，这是 Kubernetes 集群内置的 ClusterRole 对象，我们可以使⽤ kubectl get clusterrole 和 kubectl get clusterrolebinding 查看系统内置的⼀些集群⻆⾊和集群⻆⾊绑定，这 ⾥我们使⽤的 cluster-admin 这个集群⻆⾊是拥有最⾼权限的集群⻆⾊，所以⼀般需要谨慎使⽤该集群 ⻆⾊。

创建上⾯集群⻆⾊绑定资源对象，创建完成后同样使⽤ ServiceAccount 对应的 token 去登录 Dashboard 验证下：

```
[root@adm-master2 home]# kubectl get secret ralph-sa2-token-lbqlg -o jsonpath={.data.token} -n gomo-test |base64 -d
eyJhbGciOiJSUzI1NiIsImtpZCI6IkhnbVJnUGRpcHBqZG5OMVliUDV2ZlRTd0VxOFJWSnNaTzdhUnUtWExjUmcifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJnb21vLXRlc3QiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlY3JldC5uYW1lIjoicmFscGgtc2EyLXRva2VuLWxicWxnIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQubmFtZSI6InJhbHBoLXNhMiIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6IjhjNjllOWNmLWJhNTAtNGNjMS05NWRhLTUxOTczMTZjNjhhYSIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDpnb21vLXRlc3Q6cmFscGgtc2EyIn0.JrbM4737J4eQ1YfSlkDF6DrP6x8IDivpIazsaPa8WcAaA2UJy-821jxTDtnJIUv2ManAhTJ0nCiTkTECdTNQV-PygjOZjYceTykSwE25gFUeWsMS7IuJ5skTwb4gfv2eowC7wfwzFY4_KcKOMTFf-XZwhI5To6vmARGp_Am7hu9y3G3xDvylj0sbcTEU4gfk5O2nLIYiIAqRz9Kz9iVol6sxvwiUkdNVwJ1yo7PmhypcHJK3ZbifHGVMOilwSyGIbE3Hvhkv5wuWKGaHBP4gTOawENtasqOVe2t5y447vmCCkgKfoFFHOWOqvVczl6LT-DLM2QolBaqj-qKx4f00pg
```

![image-20200103111649579](C:\Users\wangjiadesx\AppData\Roaming\Typora\typora-user-images\image-20200103111649579.png)

## 14.3 POD安全策略配置

Pod Security Policies（ POD安全策略）可以非常详细的分配POD资源和更新授权

### 14.3.1什么是Pod安全策略？

Pod Security Policies是一个群集级别的资源，psp 控制着POD安全方面的规范。这些`PodSecurityPolicy`对象定义了Pod必须运行的一组条件才能被系统接受，以及相关字段的默认值。它们允许管理员控制以下各项：

| Control Aspect                                               | Field Names                                                  |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| Running of privileged containers以特权运行容器               | [`privileged`](https://kubernetes.io/docs/concepts/policy/pod-security-policy/#privileged) |
| Usage of host namespaces使用宿主名称空间                     | [`hostPID`, `hostIPC`](https://kubernetes.io/docs/concepts/policy/pod-security-policy/#host-namespaces) |
| Usage of host networking and ports使用宿主网络和端口         | [`hostNetwork`, `hostPorts`](https://kubernetes.io/docs/concepts/policy/pod-security-policy/#host-namespaces) |
| Usage of volume types使用存储卷类型                          | [`volumes`](https://kubernetes.io/docs/concepts/policy/pod-security-policy/#volumes-and-file-systems) |
| Usage of the host filesystem使用宿主机文件系统               | [`allowedHostPaths`](https://kubernetes.io/docs/concepts/policy/pod-security-policy/#volumes-and-file-systems) |
| White list of FlexVolume driversflex存储卷白名单             | [`allowedFlexVolumes`](https://kubernetes.io/docs/concepts/policy/pod-security-policy/#flexvolume-drivers) |
| Allocating an FSGroup that owns the pod’s volumes分配拥有 Pod 数据卷的 FSGroup | [`fsGroup`](https://kubernetes.io/docs/concepts/policy/pod-security-policy/#volumes-and-file-systems) |
| Requiring the use of a read only root file system只读root文件系统 | [`readOnlyRootFilesystem`](https://kubernetes.io/docs/concepts/policy/pod-security-policy/#volumes-and-file-systems) |
| The user and group IDs of the container容器的用户id和组id    | [`runAsUser`, `runAsGroup`, `supplementalGroups`](https://kubernetes.io/docs/concepts/policy/pod-security-policy/#users-and-groups) |
| Restricting escalation to root privileges禁止提升到root权限  | [`allowPrivilegeEscalation`, `defaultAllowPrivilegeEscalation`](https://kubernetes.io/docs/concepts/policy/pod-security-policy/#privilege-escalation) |
| Linux capabilities  Linux能力                                | [`defaultAddCapabilities`, `requiredDropCapabilities`, `allowedCapabilities`](https://kubernetes.io/docs/concepts/policy/pod-security-policy/#capabilities) |
| The SELinux context of the container SELinux上下文           | [`seLinux`](https://kubernetes.io/docs/concepts/policy/pod-security-policy/#selinux) |
| The Allowed Proc Mount types for the container  允许容器加载的proc类型 | [`allowedProcMountTypes`](https://kubernetes.io/docs/concepts/policy/pod-security-policy/#allowedprocmounttypes) |
| The AppArmor profile used by containers                      | [annotations](https://kubernetes.io/docs/concepts/policy/pod-security-policy/#apparmor) |
| The seccomp profile used by containers                       | [annotations](https://kubernetes.io/docs/concepts/policy/pod-security-policy/#seccomp) |
| The sysctl profile used by containers                        | [`forbiddenSysctls`,`allowedUnsafeSysctls`](https://kubernetes.io/docs/concepts/policy/pod-security-policy/#sysctl) |

### 14.3.2启用Pod安全策略

Pod安全策略控制是可选的（但建议使用） [admission controller准入控制器](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#podsecuritypolicy)。通过[启用准入控制器](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#how-do-i-turn-on-an-admission-control-plug-in)来强制执行PodSecurityPolicies ，但是在未授权任何策略的情况下这样做**将阻止**在集群**中创建任何Pod**。

由于Pod安全策略API（`policy/v1beta1/podsecuritypolicy`）是独立于准入控制器启用的，因此，对于现有群集，建议在启用准入控制器之前添加和授权策略。

### 14.3.2授权政策

创建PodSecurityPolicy资源后，它不会执行任何操作。为了使用它，必须通过允许策略中的动词来授权请求用户或目标pod的[服务帐户](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/)使用`use`该策略。

大多数Kubernetes容器不是由用户直接创建的。而是通常通过控制器管理器将它们作为[Deployment](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/)， [ReplicaSet](https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/)或其他模板化控制器的一部分间接创建 。向控制器授予对策略的访问权限将为该控制器创建的*所有* Pod 授予访问权限，因此，授权策略的首选方法是向Pod的服务帐户授予访问权限（请参见[示例](https://kubernetes.io/docs/concepts/policy/pod-security-policy/#run-another-pod)）。

### 通过RBAC

[RBAC](https://kubernetes.io/docs/reference/access-authn-authz/rbac/)是标准的Kubernetes授权模式，可以轻松地用于授权使用策略。

首先，`Role`或`ClusterRole`需要授予`use`对所需策略的访问权限。授予访问权限的规则如下所示：

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: <role name>
rules:
- apiGroups: ['policy']
  resources: ['podsecuritypolicies']
  verbs:     ['use']
  resourceNames:
  - <list of policies to authorize>
```

然后，`(Cluster)Role`将绑定到授权用户：

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: <binding name>
roleRef:
  kind: ClusterRole
  name: <role name>
  apiGroup: rbac.authorization.k8s.io
subjects:
# Authorize specific service accounts:
- kind: ServiceAccount
  name: <authorized service account name>
  namespace: <authorized pod namespace>
# Authorize specific users (not recommended):
- kind: User
  apiGroup: rbac.authorization.k8s.io
  name: <authorized user name>
```

如果使用`RoleBinding`（而不是`ClusterRoleBinding`），则只会授予在与绑定相同的名称空间中运行的pod的使用权限。可以将其与系统组配对以授予对在命名空间中运行的所有Pod的访问权限：

```yaml
# Authorize all service accounts in a namespace:
- kind: Group
  apiGroup: rbac.authorization.k8s.io
  name: system:serviceaccounts
# Or equivalently, all authenticated users in a namespace:
- kind: Group
  apiGroup: rbac.authorization.k8s.io
  name: system:authenticated
```

有关RBAC绑定的更多示例，请参见“ [角色绑定示例”](https://kubernetes.io/docs/reference/access-authn-authz/rbac#role-binding-examples)。有关授权PodSecurityPolicy的完整示例，请参见 [下文](https://kubernetes.io/docs/concepts/policy/pod-security-policy/#example)。

### 14.3.3Policy Order

除了限制容器的创建和更新之外，容器安全策略还可以用于为其控制的许多字段提供默认值。当有多个策略可用时，pod安全策略控制器将根据以下条件选择策略：

1. 首选PodSecurityPolicies，它允许按原样放置Pod，而不更改默认值或更改Pod。这些不变的PodSecurityPolicies的顺序无关紧要。
2. 如果必须将Pod设置为默认或突变，则选择第一个PodSecurityPolicy（按名称排序）以允许Pod。

> **Note:** During update operations (during which mutations to pod specs are disallowed) only non-mutating PodSecurityPolicies are used to validate the pod.

```
[root@adm-master1 home]# kubectl create namespace gomo-test
[root@adm-master1 home]# kubectl create serviceaccount -n gomo-test gomouser
serviceaccount/gomouser created
[root@adm-master1 home]# kubectl create rolebinding -n gomo-test fake-editor --clusterrole=edit --serviceaccount=gomo-test:gomouser
rolebinding.rbac.authorization.k8s.io/fake-editor created
```

为了弄清楚我们正在扮演哪个用户并保存一些输入，创建2个别名：

```
[root@adm-master1 home]# alias kubectl-admin='kubectl -n gomo-test'
[root@adm-master1 home]# alias kubectl-user='kubectl --as=system:serviceaccount:gomo-test:gomouser -n gomo-test'
```

在文件中定义示例PodSecurityPolicy对象。这是一项仅阻止创建特权POD的策略。

```
apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: example
spec:
  privileged: false  # Don't allow privileged pods!
  # The rest fills in some required fields.
  seLinux:
    rule: RunAsAny
  supplementalGroups:
    rule: RunAsAny
  runAsUser:
    rule: RunAsAny
  fsGroup:
    rule: RunAsAny
  volumes:
  - '*'
```

创建：

```
[root@adm-master1 home]# kubectl-admin create -f example-psp.yaml 
podsecuritypolicy.policy/example created
```

现在，以非特权用户身份，尝试创建一个简单的pod：

```
kubectl-user create -f- <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  containers:
    - name:  nginx
      image: wangjiadee/wbs
EOF
Error from server (Forbidden): error when creating "STDIN": pods "pause" is forbidden: unable to validate against any pod security policy: []
```

**发生了什么？**尽管已创建PodSecurityPolicy，但该Pod的服务帐户`gomouser`均无权使用新策略：

```
[root@adm-master1 home]# kubectl-user auth can-i use podsecuritypolicy/example
Warning: resource 'podsecuritypolicies' is not namespace scoped in group 'policy'
no
```



## 14.4 Namespace资源配额管理

由`ResourceQuota`对象定义的资源配额提供了限制每个命名空间的总资源消耗的约束。它可以按类型限制可在命名空间中创建的对象数量，以及该项目中的资源可能消耗的计算资源总量。

资源配额的工作方式如下：

- 不同的团队在不同的名称空间中工作。目前这是自愿的，但计划支持通过ACL强制执行此操作。
- 管理员为每个名称空间创建一个`ResourceQuota`。
- 用户在名称空间中创建资源（pod，服务等），quota system监控使用情况以确保其不超过定义在`ResourceQuota`中的硬资源限制。
- 如果创建或更新资源违反了配额限制，则请求将失败，并显示HTTP状态代码`403 FORBIDDEN`和一条消息。
- 如果在命名空间中为诸如`cpu`和的计算资源启用了配额`memory`，则用户必须为这些值指定请求或限制；否则，配额系统可能会拒绝POD创建。提示：使用`LimitRanger`准入控制器为没有计算资源要求的Pod强制使用默认值。有关如何避免此问题的示例，请参见[演练](https://kubernetes.io/docs/tasks/administer-cluster/quota-memory-cpu-namespace/)。

可以使用名称空间和配额创建的策略示例如下：

- 在容量为32 GiB RAM和16个内核的群集中，让团队A使用20 GiB和10内核，让团队B使用10GiB和4内核，并保留2GiB和2内核以备将来分配。
- 将“测试”名称空间限制为使用1个内核和1GiB RAM。让“生产”名称空间使用任意数量。

在群集的总容量小于名称空间的配额总和的情况下，可能会争用资源。这是按照先到先得的原则处理的。

**不管是抢占或更改配额都不会影响已经创建的资源。**

## 示例

我们为 `spark-cluster` 这个 namespace 设置 `ResouceQuota` 和 `LimitRange`。

以下 yaml 文件可以在 [kubernetes-handbook](https://github.com/rootsongjc/kubernetes-handbook) 的 `manifests/spark-with-kubernetes-native-scheduler` 目录下找到。

### 配置计算资源配额

配置文件：`spark-compute-resources.yaml`

```
apiVersion: v1kind: ResourceQuotametadata:  name: compute-resources  namespace: spark-clusterspec:  hard:    pods: "20"    requests.cpu: "20"    requests.memory: 100Gi    limits.cpu: "40"    limits.memory: 200Gi
```

要想查看该配置只要执行：

```
kubectl -n spark-cluster describe resourcequota compute-resources
```

### 配置对象数量限制

配置文件：`spark-object-counts.yaml`

```
apiVersion: v1kind: ResourceQuotametadata:  name: object-counts  namespace: spark-clusterspec:  hard:    configmaps: "10"    persistentvolumeclaims: "4"    replicationcontrollers: "20"    secrets: "10"    services: "10"    services.loadbalancers: "2"
```

### 配置CPU和内存LimitRange

配置文件：`spark-limit-range.yaml`

```
apiVersion: v1kind: LimitRangemetadata:  name: mem-limit-rangespec:  limits:  - default:      memory: 50Gi      cpu: 5    defaultRequest:      memory: 1Gi      cpu: 1    type: Container
```

- `default` 即 limit 的值
- `defaultRequest` 即 request 的值

