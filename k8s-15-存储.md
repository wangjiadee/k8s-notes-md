# 15、 存储

对于k8s来说 存储卷不是容器 而是一种pod。

使用脱离节点的存储设备---来提供存储能力

管理存储与管理计算机实例是不同的问题。PersistentVolume子系统为用户和管理员提供了一个API，它从存储的使用方式中抽象出存储提供方式的细节。为此，我们引入了两个新的API资源:PersistentVolume和PersistentVolumeClaim。

持久性卷(PV)是集群中的一段存储，由管理员提供或使用存储类动态提供。它是集群中的资源，就像节点是集群资源一样。PV是与卷类似的卷插件，但其生命周期独立于使用PV的任何单独Pod。这个API对象捕获存储的实现细节，无论是NFS、iSCSI还是特定于云提供程序的存储系统。

PersistentVolumeClaim (PVC)是用户对存储的请求。它类似于POD。pod消耗节点资源，而pvc消耗PV资源。Pods可以请求特定级别的资源(CPU和内存)。calaims可以请求特定的大小和访问模式(例如，它们可以挂载一次读/写或多次只读)。

虽然PersistentVolumeClaims允许用户使用抽象的存储资源，但是对于不同的问题，用户通常需要具有不同属性(例如性能)的持久卷。集群管理员需要能够提供各种不同于大小和访问模式的持久性卷，而不需要向用户展示这些卷是如何实现的。对于这些需求，有StorageClass资源。

## 15.1 pv 和pvc 

Pvc 和 pv 相关联，且pv 才是真正的存储。Pv 和底层存储相关联

存储类：根据某些存储的特性给存储做分类

官方文档： https://kubernetes.io/docs/concepts/storage/storage-classes/

![img](file:///C:\Users\WANGJI~1\AppData\Local\Temp\ksohtml14624\wps5.jpg) 

![img](file:///C:\Users\WANGJI~1\AppData\Local\Temp\ksohtml14624\wps6.jpg) 

#### PV的yaml文件：

Capacity：和传统的容量不一样 是要在最后面添加i .如5Gi

ACCESSMODES 是一种列表

The access modes are:

· ReadWriteOnce – the volume can be mounted as read-write by a single node

· ReadOnlyMany – the volume can be mounted read-only by many nodes

· ReadWriteMany – the volume can be mounted as read-write by many nodes

In the CLI, the access modes are abbreviated to:

· RWO - ReadWriteOnce

· ROX - ReadOnlyMany

· RWX - ReadWriteMany



Pv的yaml文件定义：

```
apiVersion: v1
kind: PersistentVolume
metadata:
  name: task-pv-volume
  labels:
    type: local
spec:
  storageClassName: manual
  capacity:
    storage: 10Gi
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: "/mnt/data"
```

#### PVC的yaml文件：

AccessModes 访问模型

Resource 资源限制 （最小资源  需要有多少个G... 去和PV匹配）

Selector 标签

Volumename  用于精确匹配

```
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: task-pv-claim
spec:
  storageClassName: manual
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 3Gi
```

 实验演示：https://kubernetes.io/docs/tasks/configure-pod-container/configure-persistent-volume-storage/

 

### 15.1.1数据卷的概述

在Docker中就有数据卷的概念，当容器删除时，数据也会被一起删除，想要持久化业务数据，需要把宿主机上的目录挂载到Docker中去，在K8S中，数据卷是通过Pod实现持久化的，如果Pod删除，数据卷也会一起删除，k8s的数据卷是docker数据卷的扩展，K8S适配各种存储系统，包括本地存储EmptyDir,HostPath,网络存储NFS,GlusterFS,PV/PVC等，

（需要脱离节点的存储设备 共享存储设备）

详细请看15.5张杰

### 15.1.2pv和pvc 之间的关系

![img](file:///C:\Users\WANGJI~1\AppData\Local\Temp\ksohtml14624\wps7.jpg) 

- Pv 和 pvc 都是k8s 上的一种抽象的资源

- Pv 和 pvc 一一对应， pvc 可以和多个pod 对应（设置类型）

- Pv不能定义名称空间，因为是集群级别的，不属于名称空间。而pvc是名称空间 可以定义；

- Pvc 是存储在etcd当中。如果删掉了PVC，pv是否还会在取决于pv 的回收策略

- 1.9之前 可以直接删除pv  
- 1.10之后 使用的pv 不能直接被删除

![img](file:///C:\Users\WANGJI~1\AppData\Local\Temp\ksohtml14624\wps8.jpg) 

### 15.1.3 pv的生命周期

PV是集群中的资源。PVC是对这些资源的请求，并且还充当对资源的声明检查。PV和PVC之间的交互遵循以下生命周期：

1. ### Provisioning

可以通过两种方式设置PV：静态或动态。

- #### 静态的

集群管理员创建许多PV。它们带有实际存储的详细信息，可供群集用户使用。它们存在于Kubernetes API中，可供使用。

- #### 动态

当管理员创建的所有静态PV均与用户的静态PV不匹配时`PersistentVolumeClaim`，群集可能会尝试动态地为PVC专门配置一个卷。此供应基于`StorageClasses`：PVC必须请求 [存储类](https://kubernetes.io/docs/concepts/storage/storage-classes/)，并且管理员必须已经创建并配置了该类，才能进行动态供应。要求该类的声明`""`实际上为其自身禁用了动态预配置。

要基于存储类别启用动态存储配置，集群管理员需要 在API服务器上启用`DefaultStorageClass` [准入控制器](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass)。例如，这可以通过确保API服务器组件`DefaultStorageClass`的`--enable-admission-plugins`标志的值位于逗号分隔的有序列表中来完成。有关API服务器命令行标志的更多信息，请查看[kube-apiserver](https://kubernetes.io/docs/admin/kube-apiserver/)文档。



### 15.14. pv的动态供给（storage class）

k8s的标准资源 借助中间层来完成

PV是运维人员来创建的，开发操作PVC，可是大规模集群中可能会有很多PV，如果这些PV都需要运维手动来处理这也是一件很繁琐的事情，所以就有了动态供给概念，也就是Dynamic Provisioning。而我们上面的创建的PV都是静态供给方式，也就是Static Provisioning。而动态供给的关键就是StorageClass，它的作用就是创建PV模板。

 

![img](file:///C:\Users\WANGJI~1\AppData\Local\Temp\ksohtml14624\wps9.jpg) 

 

![img](file:///C:\Users\WANGJI~1\AppData\Local\Temp\ksohtml14624\wps10.jpg) 

 

 A `StorageClass`为管理员提供了一种描述他们提供的存储“类”的方式。不同的类可能会映射到服务质量级别，备份策略或群集管理员确定的任意策略。Kubernetes本身对类表示什么没有意见。在其他存储系统中，有时也将此概念称为“配置文件”。

  每个`StorageClass`字段都包含，，和 字段`provisioner`，当需要动态设置属于该类的所属字段时使用。`parameters``reclaimPolicy``PersistentVolume`

`StorageClass`对象的名称很重要，它是用户可以请求特定类的方式。管理员在首次创建`StorageClass`对象时设置类的名称和其他参数，并且一旦创建对象便无法更新。

管理员可以`StorageClass`仅为不要求绑定任何特定类的PVC 指定默认值： 有关详细信息，请参阅[`PersistentVolumeClaim`节](https://kubernetes.io/docs/concepts/storage/persistent-volumes/#class-1)。

```
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: standard
provisioner: kubernetes.io/aws-ebs
parameters:
  type: gp2
reclaimPolicy: Retain
allowVolumeExpansion: true
mountOptions:
  - debug
volumeBindingMode: Immediate
```

说白了：pv的静态供给就是 管理员人为的去创建PV PVC ，而动态供给就是 自动的去创建合适的pv，不需要提前去创建

（上面是来自官方文档的实例，自动创建来只亚马逊的EBS）



## 15.2ConfigMap（特殊类型的存储）

很多情况下我们为某一应用做好镜像，当我们想修改其中的一些参数的时候，就变得比较麻烦，又要重新制作镜像，我们是不是有一种方式，让镜像根据不同的场景调用我们不同的配置文件呢，那我们就需要用到 k8s 的另外一种资源，那就是 ConfigMap。（里面放的就是配置信息）

   主要作用：提供了从集群外部向pod内部的注入配置文件信息

Configmap就相等于kubernetes里面的配置中心，不把配置文件写死在镜像中，configmap可以像存储卷一样使用

 缺点明文传输数据

![img](file:///C:\Users\WANGJI~1\AppData\Local\Temp\ksohtml14624\wps11.jpg) 

![img](file:///C:\Users\WANGJI~1\AppData\Local\Temp\ksohtml14624\wps12.jpg) 

配置容器化应用的方式：

 1 自定义命令行参数：

```
 Commond：
 args：[]
```

 2 把配置文件直接作出镜像（写死了）

 3 环境变量

   1应用程序本身支持  Cloud native的应用程序一般可以直接通过环境变量加载配置

   2预处理脚本 通过entrypoint脚本来预处理变量去设置配置信息）

 4 存储卷  

把配置文件放入存储卷当中 运行前去加载

 5 docker config （在docker中）

 

### 15.2.1：configmap的参数配置信息

·属于namespace（名称空间级别的资源）

·结构简单 没有spec

```
KIND:     Pod
VERSION:  v1

RESOURCE: configMap <Object>

DESCRIPTION:
     ConfigMap represents a configMap that should populate this volume

     Adapts a ConfigMap into a volume. The contents of the target ConfigMap's
     Data field will be presented in a volume as files using the keys in the
     Data field as the file names, unless the items element is populated with
     specific mappings of keys to paths. ConfigMap volumes support ownership
     management and SELinux relabeling.

FIELDS:
   defaultMode	<integer>
     Optional: mode bits to use on created files by default. Must be a value
     between 0 and 0777. Defaults to 0644. Directories within the path are not
     affected by this setting. This might be in conflict with other options that
     affect the file mode, like fsGroup, and the result can be other mode bits
     set.

   items	<[]Object>
     If unspecified, each key-value pair in the Data field of the referenced
     ConfigMap will be projected into the volume as a file whose name is the key
     and content is the value. If specified, the listed keys will be projected
     into the specified paths, and unlisted keys will not be present. If a key
     is specified which is not present in the ConfigMap, the volume setup will
     error unless it is marked optional. Paths must be relative and may not
     contain the '..' path or start with '..'.

   name	<string>
     Name of the referent. More info:
     https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names

   optional	<boolean>
     Specify whether the ConfigMap or it's keys must be defined
```



[configMap](https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/) 资源提供了向 Pod 注入配置数据的方法。 ConfigMap 对象中存储的数据可以被 configMap 类型的卷引用，然后被应用到 Pod 中运行的容器化应用。

当引用 configMap 对象时，你可以简单的在 Volume 中通过它名称来引用。 还可以自定义 ConfigMap 中特定条目所要使用的路径。

·Configmap 使用的是键值对，并且键值对没有长度限制

  	·每一个key都表示一个或一段配置参数

```
[root@k8s-master-1:sxtest]# kubectl explain configmap
KIND:     ConfigMap
VERSION:  v1

DESCRIPTION:
     ConfigMap holds configuration data for pods to consume.

FIELDS:
   apiVersion	<string>
     APIVersion defines the versioned schema of this representation of an
     object. Servers should convert recognized schemas to the latest internal
     value, and may reject unrecognized values. More info:
     https://git.k8s.io/community/contributors/devel/api-conventions.md#resources

   binaryData	<map[string]string>  // 二进制
     BinaryData contains the binary data. Each key must consist of alphanumeric
     characters, '-', '_' or '.'. BinaryData can contain byte sequences that are
     not in the UTF-8 range. The keys stored in BinaryData must not overlap with
     the ones in the Data field, this is enforced during validation process.
     Using this field will require 1.10+ apiserver and kubelet.

   data	<map[string]string>
     Data contains the configuration data. Each key must consist of alphanumeric
     characters, '-', '_' or '.'. Values with non-UTF-8 byte sequences must use
     the BinaryData field. The keys stored in Data must not overlap with the
     keys in the BinaryData field, this is enforced during validation process.
// data是有映射组成的  ---哈希 
   kind	<string>
     Kind is a string value representing the REST resource this object
     represents. Servers may infer this from the endpoint the client submits
     requests to. Cannot be updated. In CamelCase. More info:
     https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds

   metadata	<Object>
     Standard object's metadata. More info:
     https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata


如果是一次性的可以单独写
Examples:
  # Create a new configmap named my-config based on folder bar
  kubectl create configmap my-config --from-file=path/to/bar
  
  # Create a new configmap named my-config with specified keys instead of file basenames on disk
  kubectl create configmap my-config --from-file=key1=/path/to/bar/file1.txt --from-file=key2=/path/to/bar/file2.txt
  
  # Create a new configmap named my-config with key1=config1 and key2=config2
  kubectl create configmap my-config --from-literal=key1=config1 --from-literal=key2=config2
//在命令行中直接给键和值
  
  # Create a new configmap named my-config from the key=value pairs in the file
  kubectl create configmap my-config --from-file=path/to/bar
  
  # Create a new configmap named my-config from an env file
  kubectl create configmap my-config --from-env-file=path/to/bar.env
```

创建configmap实例1：

```
[root@k8s-master ~]# kubectl create configmap nginx-config --from-literal=nginx_port=80 --from-literal=server_name=node2
configmap "nginx-config" created
[root@k8s-master ~]# kubectl get cm
NAME           DATA      AGE
nginx-config   2         6s
[root@k8s-master ~]# kubectl describe cm/nginx-config
Name:		nginx-config
Namespace:	default
Labels:		<none>
Annotations:	<none>

Data
====
nginx_port:	2 bytes
server_name:	5 bytes
```

创建configmap实例2：

```
[root@k8s-master ~]# mkdir configmap
[root@k8s-master ~]# cd configmap/
[root@k8s-master configmap]# ls
[root@k8s-master configmap]# cat configmap_test.conf 
server{
	server_name node2;
	listen 80;
	root /data/web/html/;
}
[root@k8s-master configmap]# kubectl create configmap nginx-www --from-file=./configmap_test.conf 
configmap "nginx-www" created  
[root@k8s-master configmap]# kubectl get cm nginx-www -o yaml
apiVersion: v1
data:
  configmap_test.conf: "server{\n\tserver_name node2;\n\tlisten 80;\n\troot /data/web/html/;\n}\n"
kind: ConfigMap
metadata:
  creationTimestamp: 2019-10-21T08:46:48Z
  name: nginx-www
  namespace: default
  resourceVersion: "119104"
  selfLink: /api/v1/namespaces/default/configmaps/nginx-www
  uid: 5179e60e-f3df-11e9-97b1-000c290bc7bf
```

创建pod 与configmap相关的yaml文件：

```
apiVersion: v1
kind: Pod
metadata:
  name: cmtest-nginx-pod
spec:
  containers:
    - name: cmtest-nginx-pod
      image: 192.168.1.133:5000/nginx:latest
      ports:
      - name: http
        containerPort: 80
      volumeMounts:
      - name: config-volume
        mountPath: /etc/nginx/config.d
        readOnly: true
  volumes:
    - name: config-volume
      configMap:
        name: nginx-config
  restartPolicy: Never
```



使用ConfigMap有三种方式:

- 第一种是通过环境变量的方式，直接传递给pod

  ​			|—> 使用configmap中指定的key

  ​			|—> 使用configmap中所有的key

- 第二种是通过在pod的命令行下运行的方式(启动命令中)

- 第三种是作为volume的方式挂载到pod内


 

 

(1)使用valueFrom、configMapKeyRef、name、key指定要用的key:

```
apiVersion: v1
kind: Pod
metadata:
  name: dapi-test-pod
spec:
  containers:
    - name: test-container
      image: k8s.gcr.io/busybox
      command: [ "/bin/sh", "-c", "env" ]
      env:
        - name: SPECIAL_LEVEL_KEY
          valueFrom:
            configMapKeyRef:
              name: special-config
              key: special.how
        - name: LOG_LEVEL
          valueFrom:
            configMapKeyRef:
              name: env-config
              key: log_level
  restartPolicy: Never

```

(2) 还可以通过envFrom、configMapRef、name使得configmap中的所有key/value对都自动变成环境变量：

```
apiVersion: v1
kind: Pod
metadata:
  name: dapi-test-pod
spec:
  containers:
    - name: test-container
      image: k8s.gcr.io/busybox
      command: [ "/bin/sh", "-c", "env" ]
      envFrom:
      - configMapRef:
          name: special-config
  restartPolicy: Never
```

在启动命令中引用

```
apiVersion: v1
kind: Pod
metadata:
  name: dapi-test-pod
spec:
  containers:
    - name: test-container
      image: k8s.gcr.io/busybox
      command: [ "/bin/sh", "-c", "echo $(SPECIAL_LEVEL_KEY) $(SPECIAL_TYPE_KEY)" ]
      env:
        - name: SPECIAL_LEVEL_KEY
          valueFrom:
            configMapKeyRef:
              name: special-config
              key: SPECIAL_LEVEL
        - name: SPECIAL_TYPE_KEY
          valueFrom:
            configMapKeyRef:
              name: special-config
              key: SPECIAL_TYPE
  restartPolicy: Never
```

 

作为volume挂载使用

```
apiVersion: v1
kind: Pod
metadata:
  name: cmtest-nginx-pod
spec:
  containers:
    - name: cmtest-nginx-pod
      image: 192.168.1.133:5000/nginx:latest
      ports:
      - name: http
        containerPort: 80
      volumeMounts:
      - name: config-volume
        mountPath: /etc/nginx/config.d
        readOnly: true
  volumes:
    - name: config-volume
      configMap:
        name: nginx-config
  restartPolicy: Never

```

假如不想以key名作为配置文件名可以引入items 字段，在其中逐个指定要用相对路径path替换的key：

```
     volumes:
      - name: config-volume4
        configMap:
          name: test-config4
          items:
          - key: my.cnf
            path: mysql-key
          - key: cache_host
            path: cache-host
```

\1. 删除configmap后原pod不受影响；然后再删除pod后，重启的pod的events会报找不到cofigmap的volume；

\2. pod起来后再通过kubectl edit configmap …修改configmap，过一会pod内部的配置也会刷新。

\3. 在容器内部修改挂进去的配置文件后，过一会内容会再次被刷新为原始configmap内容

### 实例1：configmap注入nginx的虚拟主机

启动pod的yaml 文件内容：

 

```
apiVersion: v1
kind: Pod
metadata:
  name: pod-cm-1
  namespace: default
  labels:
    app: myapp
    tier: frontend
  annotations:
    gomo.com/created-by: "wangjiadesx"
spec:
  containers:
  - name: myapp
    image: ikubernetes/myapp:v1
    ports:
    - name: http
      containerPort: 80
    volumeMounts:
    - name: ng-configmap
      mountPath: /etc/nginx/conf.d/
      readOnly: true
  volumes:
  - name: ng-configmap
    configMap:
      name: nginx-www


[root@k8s-master ~]# mkdir configmap
[root@k8s-master ~]# cd configmap/
[root@k8s-master configmap]# ls
[root@k8s-master configmap]# cat configmap_test.conf 
server{
	server_name 127.0.0.1;
	listen 80;
	root /data/web/html/;
}
[root@k8s-master configmap]# kubectl create configmap nginx-www --from-file=./configmap_test.conf 
configmap "nginx-www" created  


---------------------------------------------------
[root@k8s-master-1:~]# kubectl describe cm/nginx-www
Name:         nginx-www
Namespace:    default
Labels:       <none>
Annotations:  <none>

Data
====
configmap_test.conf:
----
server{
  server_name 127.0.0.1;
  listen 80;
  root /data/web/html/;
}

Events:  <none>
```

进入pod 自己创建index.html 完成！

```
pod-cm-1                      1/1     Running   0          3m42s   172.22.5.73    k8s-worker-4   <none>           <none>
[root@k8s-worker-2:~]# curl 172.22.5.73
<h1>xjbb!</h1>

```

### 15.2.2ConfigMap的热更新

configmap的热更新研究

更新 ConfigMap 后：

使用该 ConfigMap 挂载的 Env 不会同步更新

使用该 ConfigMap 挂载的 Volume 中的数据需要一段时间（实测大概10秒）才能同步更新

ENV 是在容器启动的时候注入的，启动之后 kubernetes 就不会再改变环境变量的值，且同一个 namespace 中的 pod 的环境变量是不断累加的，参考 Kubernetes中的服务发现与docker容器间的环境变量传递源码探究。为了更新容器中使用 ConfigMap 挂载的配置，可以通过滚动更新 pod 的方式来强制重新挂载 ConfigMap，也可以在更新了 ConfigMap 后，先将副本数设置为 0，然后再扩容。

## 15.3Secret

Secret 作用和configmap一样 只不是是多了编码方式

```
Secret 作用和configmap一样 只不是是多了编码方式

[root@k8s-master testyml]# kubectl create secret --help
Create a secret using specified subcommand.

Available Commands:
  docker-registry Create a secret for use with a Docker registry
//1认证信息 对仓库信息的认证
  generic         Create a secret from a local file, directory or literal value
//2 一般保存密码通用的   除去1和3的情况
  tls             Create a TLS secret
//3 私钥证书

Usage:
  kubectl create secret [options]

Use "kubectl <command> --help" for more information about a given command.
Use "kubectl options" for a list of global command-line options (applies to all commands).

    imagePullSecrets	<[]Object>
     ImagePullSecrets is an optional list of references to secrets in the same
     namespace to use for pulling any of the images used by this PodSpec. If
     specified, these secrets will be passed to individual puller implementations
     for them to use. For example, in the case of docker, only DockerConfig type
     secrets are honored. More info:
     http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod
```

 

## 15.5Volume[hostPath,emptyDir]

### 15.5.1 emptyDir

![img](file:///C:\Users\WANGJI~1\AppData\Local\Temp\ksohtml14624\wps13.jpg) 

·临时目录 当pod删除时候 存储也会变删除  

·关联的目录可以是宿主机的内存

·可以做缓存空间使用

### EmptyDir的解释实例1：

Yaml文件：

```
apiVersion: v1
kind: Pod
metadata:
  name: pv-demo
  namespace: default
  labels:
    app: myapp
    tier: frontend
  annotations:
    gomo-by: "gomo test"
spec:
  containers:
  - name: myapp
    image: ikubernetes/myapp:v1
    ports:
    - name: http
      containerPort: 80
    volumeMounts:
    - name: html
      mountPath: /data/web/html
  - name: busybox
    image: busybox:latest
    imagePullPolicy: IfNotPresent
    volumeMounts:
    - name: html
      mountPath: /data
    command:
    - "/bin/sh"
    - "-c"
    - "sleep 3600"
  volumes:
  - name: html
    emptyDir: {}
```

利用yaml文件创建后检测：

```
 kubectl exec -it pv-demo -c busybox -- /bin/sh
/ # ls
bin   data  dev   etc   home  proc  root  sys   tmp   usr   var
/ # echo $(date) >> /data/index.html
/ # echo $(date) >> /data/index.html
/ # echo $(date) >> /data/index.html
/ # echo $(date) >> /data/index.html
/ # echo $(date) >> /data/index.html

-------------------------------
kubectl exec -it pv-demo -c myapp -- /bin/sh
/ # ls
bin    dev    home   media  proc   run    srv    tmp    var
data   etc    lib    mnt    root   sbin   sys    usr
/ # cd /d
data/  dev/
/ # cd /data/web/html/
/data/web/html # ls
index.html
/data/web/html # cat index.html 
Thu Oct 31 06:11:21 UTC 2019
Thu Oct 31 06:11:24 UTC 2019
Thu Oct 31 06:11:26 UTC 2019
Thu Oct 31 06:11:28 UTC 2019
/data/web/html # cat index.html 
Thu Oct 31 06:11:21 UTC 2019
Thu Oct 31 06:11:24 UTC 2019
Thu Oct 31 06:11:26 UTC 2019
Thu Oct 31 06:11:28 UTC 2019
Thu Oct 31 06:15:05 UTC 2019

即 busybox容器设定 之后再另一个容器之中可以访问
```

（注意 pod删除的时候 表示存储卷丢失）

### Git repo

基于emptydir 的基础上来进行

![img](file:///C:\Users\WANGJI~1\AppData\Local\Temp\ksohtml14624\wps14.jpg) 

基于git的命令

状态只属于git clone 那一瞬间

### 15.5.2hostPath

主机路径  直接在宿主机上面找一个文件（不是具有真正意义上的持久性，但是属于节点持久性）

Type的类型

| Value             | Behavior                                                     |
| ----------------- | ------------------------------------------------------------ |
|                   | Empty string (default) is for backward compatibility, which means that no checks will be performed before mounting the hostPath volume. |
| DirectoryOrCreate | If nothing exists at the given path, an empty directory will be created there as needed with permission set to 0755, having the same group and ownership with Kubelet. |
| Directory         | A directory must exist at the given path                     |
| FileOrCreate      | If nothing exists at the given path, an empty file will be created there as needed with permission set to 0644, having the same group and ownership with Kubelet. |
| File              | A file must exist at the given path                          |
| Socket            | A UNIX socket must exist at the given path                   |
| CharDevice        | A character device must exist at the given path              |
| BlockDevice       | A block device must exist at the given path                  |

- ### hostPath的解释实例1：


```
apiVersion: v1
kind: Pod
metadata:
  name: hostpath
  namespace: default
spec:
  containers:
  - name: myapp
    image: ikubernetes/myapp:v1
    volumeMounts:
    - name: gomo
      mountPath: /usr/share/nginx/html/
  volumes:
  - name: gomo
    hostPath:
      path: /data/pod/volume1
      type: DirectoryOrCreate

```

创建并检测：

在node节点上 创建文件/usr/share/nginx/html 并写测试页 在访问检查

```
[root@k8s-worker-1:~]# mkdir -p /data/pod/volume1
[root@k8s-worker-1:~]# cd /data/pod/volume1/
[root@k8s-worker-1:volume1]# cat index.html 
gomo-test
---------------------------
[root@k8s-master-1:volumes]# kubectl get pods hostpath -o wide
NAME       READY   STATUS    RESTARTS   AGE   IP             NODE           NOMINATED NODE   READINESS GATES
hostpath   1/1     Running   0          83s   172.22.3.112   k8s-worker-1   <none>           <none>
[root@k8s-master-1:volumes]# curl 172.22.3.112
gomo-test
```

## 15.6Persistent Volume（持久化卷）

网络共享设备：

SAN（存储区域网络）:ISCSI  FC   

NAS（网络附加存储）:NFS CIFS http

分布式存储  GlusterFS，ceph（rbd），cephfs

### 15.6.1NFS

开一台nfs server 服务器

Yum -y install nfs-utils

Mkdir /共享目录

Vim /etc/export

 /共享目录  主机IP/域名（rw,sync）

exportfs -a   showmount -e

重启服务 

（监听2049端口） 

在节点上的操作：

挂载好卷

 Yaml 文件：

```
apiVersion: v1
kind: Pod
metadata:
  name: nfs
  namespace: default
spec:
  containers:
  - name: myapp
    image: ikubernetes/myapp:v1
    volumeMounts:
    - name: gomo
      mountPath: /usr/share/nginx/html/
  volumes:
  - name: gomo
Nfs:
  Path: /挂载目录
  Server：IP/域名 
```

### 15.6.2 GlusterFS

https://www.cnblogs.com/lingfenglian/p/11753938.html

### 15.6.3 云存储

EBS  Azure  Disk	

## 15.7 Storage Cl

https://blog.csdn.net/BigData_Mining/article/details/88735987